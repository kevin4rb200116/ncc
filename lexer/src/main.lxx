
%option yylineno noyywrap nounput nounistd always-interactive

%{
	#include "handle.hh"

	typedef struct YYLTYPE {
		int first_line;
		int first_column;
		int last_line;
		int last_column;

		void step();
		void columns(int count=1);
		void lines(int count=1);
	} YYLTYPE;

	extern YYLTYPE yylloc;
%}

COMMENT      #[^\r\n]*
WHITESPACE   [ \r\t]
NAME         [_a-zA-Z][_a-zA-Z0-9]*

BIN_NUMBER   0[bB](?:_?[01])+
OCT_NUMBER   0[oO](?:_?[0-7])+
DEC_NUMBER   (?:0(?:_?0)*|[1-9](?:_?[0-9])*)
HEX_NUMBER   0[xX](?:_?[0-9a-fA-F])+
FLOAT_NUMBER ([0-9](?:_?[0-9])*\.(?:[0-9](?:_?[0-9])*)?|\.[0-9](?:_?[0-9])*)

STRING       ('[^\n'\\]*(?:\\.[^\n'\\]*)*'|\"[^\n\"\\]*(?:\\.[^\n\"\\]*)*\")

%{
	// Code run each time a pattern is matched.
	# define YY_USER_ACTION yylloc.columns(yyleng);
%}
%% /* ================================= Begin ============================== */

"("            return handle::LPAR();
")"            return handle::RPAR();
","            return handle::COMMA();
";"            return handle::SEMI();
"+"            return handle::PLUS();
"-"            return handle::MINUS();
"*"            return handle::STAR();
"/"            return handle::SLASH();

"def"          return handle::DEF();
"extern"       return handle::EXTERN();

{WHITESPACE}+  yylloc.step();
{COMMENT}      yylloc.lines(); yylloc.step();
\n+            

{NAME}         return handle::NAME(yytext);
{BIN_NUMBER}   return handle::BIN_NUMBER(yytext);
{OCT_NUMBER}   return handle::OCT_NUMBER(yytext);
{DEC_NUMBER}   return handle::DEC_NUMBER(yytext);
{HEX_NUMBER}   return handle::HEX_NUMBER(yytext);
{FLOAT_NUMBER} return handle::FLOAT_NUMBER(yytext);

.              return handle::YYerror();
<<EOF>>        return handle::YYEOF();

%% /* ================================= End ============================== */

void YYLTYPE::step() {
	first_line = last_line;
	first_column = last_column;
}

void YYLTYPE::columns(int count) {
	last_column = last_column + count < 1 ? 1 : last_column + count;
}

void YYLTYPE::lines(int count) {
	if (count) {
		last_column = 1;
		last_line = last_line + count < 1 ? 1 : last_line + count;
	}
}
