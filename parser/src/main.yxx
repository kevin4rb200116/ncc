
%require "3.8.2"
%header
%locations

%{
  #include <string>
  #include <vector>

  #include "ast.hh"
  #include "parser.hh"
  #include "lexer.hh"

  using std::string;
  using std::vector;

  int yyerror(const char *msg);
%}

%union{
  char *cstring;
  void *pointer;
}

%define api.token.prefix {TOKEN_}
%token
  LPAR
  RPAR
  LSQB
  RSQB
  COLON
  COMMA
  SEMI
  PLUS
  MINUS
  STAR
  SLASH
  VBAR
  AMPER
  LESS
  GREATER
  EQUAL
  DOT
  PERCENT
  LBRACE
  RBRACE
  EQEQUAL
  NOTEQUAL
  LESSEQUAL
  GREATEREQUAL
  TILDE
  CIRCUMFLEX
  LEFTSHIFT
  RIGHTSHIFT
  DOUBLESTAR
  PLUSEQUAL
  MINEQUAL
  STAREQUAL
  SLASHEQUAL
  PERCENTEQUAL
  AMPEREQUAL
  VBAREQUAL
  CIRCUMFLEXEQUAL
  LEFTSHIFTEQUAL
  RIGHTSHIFTEQUAL
  DOUBLESTAREQUAL
  DOUBLESLASH
  DOUBLESLASHEQUAL
  ELLIPSIS
  RARROW
  AT
  ATEQUAL
  DEF
  EXTERN
  ;
//token

%token <cstring>
  // WHITESPACE
  COMMENT
  NAME
  HEX_NUMBER
  BIN_NUMBER
  OCT_NUMBER
  DEC_NUMBER
  FLOAT_NUMBER
  STRING
  ;
// token

%type <pointer> number
%type <pointer> name

%type <pointer> expression // ast::Expression*
%type <pointer> top_level  // ast::Function*
%type <pointer> external   // ast::Prototype*
%type <pointer> prototype  // ast::Prototype*
%type <pointer> primary    // ast::Expression*
%type <pointer> definition // ast::Function*

%type <pointer> call_args  // vector<ast::Expression*>
%type <pointer> proto_args // vector<string>

%% /* ================================= Begin ============================== */

%start program;

program:
    %empty
  | program statement
  ;

statement:
    external   SEMI { printf("an external\n"); }
  | definition SEMI { printf("a definition\n"); }
  | top_level  SEMI { printf("an top_level expr\n"); }
  ;

definition[expr]:
  prototype[proto] expression[body] {
    $expr = (void*) new ast::Function(
      (ast::Prototype*) $proto,
      (ast::Expression*) $body
    );
  }

top_level[expr]:
  expression[body] {
    $expr = (void*) new ast::Function(
      new ast::Prototype(
        "__anon_expr",
        new vector<string>()
      ),
      (ast::Expression*) $body
    );
  }

  ;

proto_args[expr]:
    NAME[arg] {
      $expr = (void*) new vector<string>();

      ((vector<string>*) $expr)
        -> push_back(string($arg));
    }

  | proto_args[rest] COMMA NAME[arg] {
    $expr = $rest;

    ((vector<string>*) $expr)
      -> push_back(string($arg));
  }

  ;

prototype[expr]:
    DEF NAME[name] LPAR proto_args[args] RPAR {
      $expr = (void*) new ast::Prototype(
        string($name),
        (vector<string>*) $args
      );
    }

  | DEF NAME[name] LPAR RPAR {
    $expr = (void*) new ast::Prototype(
      string($name),
      new vector<string>()
    );
  }

  ;

external[expr]:
    EXTERN NAME[name] LPAR proto_args[args] RPAR {
      $expr = (void*) new ast::Prototype(
        string($name),
        (vector<string>*) $args
      );
    }

  | EXTERN NAME[name] LPAR RPAR {
    $expr = (void*) new ast::Prototype(
      string($name),
      new vector<string>()
    );
  }

  ;

expression[expr]:
    primary

  | expression[lhs] PLUS primary[rhs] {
    $expr = (void*) new ast::Binary(
      "+",
      (ast::Expression*) $lhs,
      (ast::Expression*) $rhs
    );
  }

  | expression[lhs] MINUS primary[rhs] {
    $expr = (void*) new ast::Binary(
      "-",
      (ast::Expression*) $lhs,
      (ast::Expression*) $rhs
    );
  }

  | expression[lhs] STAR primary[rhs] {
    $expr = (void*) new ast::Binary(
      "*",
      (ast::Expression*) $lhs,
      (ast::Expression*) $rhs
    );
  }

  | expression[lhs] SLASH primary[rhs] {
    $expr = (void*) new ast::Binary(
      "/",
      (ast::Expression*) $lhs,
      (ast::Expression*) $rhs
    );
  }

  ;

primary[expr]:
    name

  | number

  | LPAR expression[pexpr] RPAR {
    $expr = $pexpr;
  }

  ;

call_args[expr]:
    expression[arg] {
      $expr = (void*) new vector<ast::Expression*>();

      ((vector<ast::Expression*>*) $expr)
        -> push_back((ast::Expression*) $arg);
    }

  | call_args[rest] COMMA expression[arg] {
    $expr = $rest;

    ((vector<ast::Expression*>*) $expr)
      -> push_back((ast::Expression*) $arg);
  }

  ;

name[expr]:
    NAME[str] {
      $expr = (void*) new ast::Variable(string($str));
    }

  | NAME[str] LPAR call_args[args] RPAR {
    $expr = (void*) new ast::Call(
      string($str),
      (vector<ast::Expression*>*) $args
    );
  }

  | NAME[str] LPAR RPAR {
    $expr = (void*) new ast::Call(
      string($str),
      new vector<ast::Expression*>()
    );
  }

  ;

number[expr]:
    BIN_NUMBER[str]   {
      $expr = (void*) new ast::Number(
        string($str),
        ast::Number::BIN_NUMBER
      );
    }

  | OCT_NUMBER[str]   {
    $expr = (void*) new ast::Number(
      string($str),
      ast::Number::OCT_NUMBER
    );
  }

  | DEC_NUMBER[str]   {
    $expr = (void*) new ast::Number(
      string($str),
      ast::Number::DEC_NUMBER
    );
  }

  | HEX_NUMBER[str]   {
    $expr = (void*) new ast::Number(
      string($str),
      ast::Number::HEX_NUMBER
    );
  }

  | FLOAT_NUMBER[str] {
    $expr = (void*) new ast::Number(
      string($str),
      ast::Number::FLOAT_NUMBER
    );
  }

  ;

%% /* ================================= End ============================== */

int yyerror(const char *msg) {
	fprintf(
		stderr,
		"Error %d.%d-%d.%d: %s\n",
		yylloc.first_line,
		yylloc.first_column,
		yylloc.last_line,
		yylloc.last_column,
		msg
	);

	return 0;
}
